<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1.0" />
  <title>Levipark21 - Recorrido 1ª persona</title>

  <style>
    :root {
      --ui-bg: rgba(255,255,255,0.9);
      --accent: #006eff;
      --ui-radius: 8px;
    }

    html, body {
      height: 100%;
      margin: 0;
      font-family: Arial, Helvetica, sans-serif;
      background: #fff;
      -webkit-user-select: none; user-select: none;
      touch-action: none; /* importantes para touch */
    }

    /* Header */
    #header {
      width: 100%;
      max-width: 1000px;
      margin: 8px auto 0;
      padding: 8px 12px;
      box-sizing: border-box;
      display: flex;
      gap: 12px;
      align-items: center;
      justify-content: space-between;
      background: var(--ui-bg);
      border-radius: var(--ui-radius);
      z-index: 50;
      position: relative;
    }
    #title {
      font-weight: 700;
      color: #222;
      margin: 0;
      font-size: 18px;
    }
    #modelSelector {
      padding: 8px 10px;
      font-size: 15px;
      border-radius: 6px;
      border: 1px solid #ccc;
      background: white;
    }

    /* Canvas container */
    #canvas-wrap {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: calc(64px + 16px); /* header height + gap */
      bottom: 0;
      width: 100%;
      max-width: 1000px;
      box-sizing: border-box;
      overflow: hidden;
      z-index: 1;
    }
    canvas {
      width: 100% !important;
      height: 100% !important;
      display: block;
    }

    /* Joystick & touch UI (mobile) */
    .joystick {
      position: fixed;
      bottom: 24px;
      left: 24px;
      width: 110px;
      height: 110px;
      border-radius: 999px;
      background: rgba(0,0,0,0.10);
      display: none; /* solo mobile */
      z-index: 60;
      touch-action: none;
      align-items: center;
      justify-content: center;
    }
    .joystick .stick {
      width: 52px;
      height: 52px;
      border-radius: 999px;
      background: rgba(0,0,0,0.25);
      transform: translate(0,0);
      transition: transform 0.05s;
      pointer-events: none;
    }

    .look-area {
      position: fixed;
      bottom: 24px;
      right: 24px;
      width: 40%;
      max-width: 420px;
      height: 48%;
      max-height: 420px;
      border-radius: 12px;
      background: rgba(0,0,0,0.06);
      display: none; /* only mobile */
      z-index: 60;
      touch-action: none;
    }

    /* Small help text on-screen */
    #help {
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: 8px;
      z-index: 70;
      background: rgba(255,255,255,0.85);
      padding: 6px 10px;
      border-radius: 6px;
      font-size: 13px;
      color: #222;
      box-shadow: 0 2px 6px rgba(0,0,0,0.08);
    }

    /* Desktop controls hint */
    #desktop-hint {
      font-size: 13px;
      color: #444;
    }

    /* Responsive: show joystick on small screens */
    @media (pointer: coarse), (max-width: 900px) {
      .joystick, .look-area { display: flex; }
      #header { margin-top: 6px; }
      #canvas-wrap { top: 84px; } /* more top spacing for header on mobile */
    }
  </style>
</head>
<body>

  <div id="header">
    <div id="title">Levipark21 - Línea Qubiq (Recorrido)</div>
    <div style="display:flex; gap:10px; align-items:center;">
      <select id="modelSelector">
        <option value="bichos.glb">QUBIQ</option>
        <option value="coco.glb">COCODRILO</option>
        <option value="koa.glb">KOALA</option>
        <option value="pingu.glb">PINGU</option>
      </select>
      <div id="desktop-hint">W/A/S/D o flechas para moverse · Click-drag para mirar</div>
    </div>
  </div>

  <div id="canvas-wrap">
    <!-- Three.js renderer DOMElement will be appended here -->
  </div>

  <!-- Mobile joystick (left) -->
  <div id="joy" class="joystick" aria-hidden="true">
    <div class="stick" id="joy-stick"></div>
  </div>

  <!-- Touch look area (right) -->
  <div id="look" class="look-area" aria-hidden="true"></div>

  <div id="help">En móvil: joystick izquierdo = mover · arrastra derecha = mirar</div>

  <!-- import map + es-module-shims -->
  <script async src="https://unpkg.com/es-module-shims@1.6.3/dist/es-module-shims.js"></script>
  <script type="importmap">
  {
    "imports": {
      "three": "https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js",
      "three/examples/jsm/controls/FirstPersonControls.js": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/controls/FirstPersonControls.js",
      "three/examples/jsm/loaders/GLTFLoader.js": "https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js"
    }
  }
  </script>

  <script type="module">
    import * as THREE from "three";
    import { FirstPersonControls } from "three/examples/jsm/controls/FirstPersonControls.js";
    import { GLTFLoader } from "three/examples/jsm/loaders/GLTFLoader.js";

    /*********** Config & DOM ***********/
    const repoPath = './'; // tus .glb en la misma carpeta
    const container = document.getElementById('canvas-wrap');
    const selector = document.getElementById('modelSelector');

    // mobile UI elements
    const joy = document.getElementById('joy');
    const joyStick = document.getElementById('joy-stick');
    const lookArea = document.getElementById('look');

    // detect mobile / touch
    const isTouch = (('ontouchstart' in window) || navigator.maxTouchPoints > 0);

    /*********** Renderer, Scene, Camera ***********/
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0xffffff, 1);
    container.appendChild(renderer.domElement);

    const scene = new THREE.Scene();

    const camera = new THREE.PerspectiveCamera(75, container.clientWidth / container.clientHeight, 0.1, 2000);
    camera.position.set(0, 1.6, 3); // altura similar a ojos humanos

    // Lights
    const ambient = new THREE.AmbientLight(0xffffff, 0.85);
    scene.add(ambient);

    const dir = new THREE.DirectionalLight(0xffffff, 0.6);
    dir.position.set(5, 10, 7);
    scene.add(dir);

    /*********** Controls ***********/
    // FirstPersonControls expects: camera, DOM element
    const controls = new FirstPersonControls(camera, renderer.domElement);
    controls.movementSpeed = 2.2; // default walking speed, tweakable
    controls.lookSpeed = 0.08;
    controls.lookVertical = true;
    controls.constrainVertical = true;
    controls.verticalMin = 1.0;   // limit pitch
    controls.verticalMax = 2.0;

    // We'll use custom input (keyboard/touch) to set controls.moveForward/back/right/left flags.
    // FirstPersonControls checks these flags internally on update().

    /*********** Model loader ***********/
    const loader = new GLTFLoader();
    let currentModel = null;

    function disposeModel(obj) {
      obj.traverse(child => {
        if (child.geometry) child.geometry.dispose();
        if (child.material) {
          if (Array.isArray(child.material)) child.material.forEach(m => m.dispose());
          else child.material.dispose();
        }
      });
    }

    function loadModel(filename) {
      const url = repoPath + filename;
      console.log('Cargando', url);

      if (currentModel) {
        scene.remove(currentModel);
        disposeModel(currentModel);
        currentModel = null;
      }

      loader.load(url,
        (gltf) => {
          currentModel = gltf.scene;
          // scale very large models down if needed (optional)
          // currentModel.scale.setScalar(1.0);

          // center model
          const box = new THREE.Box3().setFromObject(currentModel);
          const size = new THREE.Vector3();
          box.getSize(size);
          const center = box.getCenter(new THREE.Vector3());
          currentModel.position.sub(center);

          // place model slightly in front so user can walk around it
          scene.add(currentModel);

          // optionally position camera a little further back based on model size
          const maxDim = Math.max(size.x, size.y, size.z);
          if (maxDim > 0.5) {
            camera.position.set(0, 1.6, Math.max(3, maxDim * 1.2));
          }
        },
        (xhr) => {
          if (xhr.lengthComputable) {
            const pct = (xhr.loaded / xhr.total * 100).toFixed(0);
            // console.log(`Carga ${pct}%`);
          }
        },
        (err) => {
          console.error('Error cargando modelo:', err);
          alert('Error cargando: ' + filename);
        }
      );
    }

    // initial
    loadModel(selector.value);

    selector.addEventListener('change', () => {
      loadModel(selector.value);
    });

    /*********** Keyboard controls (desktop) ***********/
    // We'll map WASD and arrow keys to controls.move flags.
    const keyState = {};
    window.addEventListener('keydown', (e) => {
      keyState[e.code] = true;
      updateMoveFlags();
    }, false);
    window.addEventListener('keyup', (e) => {
      keyState[e.code] = false;
      updateMoveFlags();
    }, false);

    function updateMoveFlags() {
      controls.moveForward = !!(keyState['KeyW'] || keyState['ArrowUp']);
      controls.moveBackward = !!(keyState['KeyS'] || keyState['ArrowDown']);
      controls.moveLeft = !!(keyState['KeyA'] || keyState['ArrowLeft']);
      controls.moveRight = !!(keyState['KeyD'] || keyState['ArrowRight']);
    }

    /*********** Touch controls (mobile) ***********/
    // Left joystick: move direction vector (forward/back/left/right)
    // Right touch-drag: look around (translate to yaw/pitch deltas)

    let joyActive = false;
    let joyId = null;
    let joyOrigin = { x: 0, y: 0 };
    let joyValue = { x: 0, y: 0 }; // normalized -1..1

    let lookActive = false;
    let lookId = null;
    let lastLookPos = { x: 0, y: 0 };

    // Show joystick & look UI only on touch devices
    if (isTouch) {
      joy.style.display = 'flex';
      lookArea.style.display = 'block';
    }

    // JOYSTICK: touchstart inside joy => start
    joy.addEventListener('touchstart', (ev) => {
      ev.preventDefault();
      const t = ev.changedTouches[0];
      joyActive = true;
      joyId = t.identifier;
      const r = joy.getBoundingClientRect();
      joyOrigin.x = r.left + r.width / 2;
      joyOrigin.y = r.top + r.height / 2;
      updateJoystickFromTouch(t.clientX, t.clientY);
    }, {passive:false});

    joy.addEventListener('touchmove', (ev) => {
      ev.preventDefault();
      for (let t of ev.changedTouches) {
        if (t.identifier === joyId) {
          updateJoystickFromTouch(t.clientX, t.clientY);
        }
      }
    }, {passive:false});

    joy.addEventListener('touchend', (ev) => {
      ev.preventDefault();
      for (let t of ev.changedTouches) {
        if (t.identifier === joyId) {
          joyActive = false;
          joyId = null;
          joyValue.x = 0; joyValue.y = 0;
          joyStick.style.transform = `translate(0px,0px)`;
          updateMoveFlagsFromJoystick();
        }
      }
    }, {passive:false});

    function updateJoystickFromTouch(tx, ty) {
      const dx = tx - joyOrigin.x;
      const dy = ty - joyOrigin.y;
      // clamp to joystick radius (half size minus padding)
      const r = 40; // radius in px for stick movement
      const dist = Math.hypot(dx, dy);
      const nx = Math.max(-1, Math.min(1, dx / r));
      const ny = Math.max(-1, Math.min(1, -dy / r)); // invert Y so up = positive
      joyValue.x = (Math.abs(nx) > 1 ? Math.sign(nx) : nx);
      joyValue.y = (Math.abs(ny) > 1 ? Math.sign(ny) : ny);
      // Update visual stick (limited)
      const visX = Math.max(-r, Math.min(r, dx)) * 0.75;
      const visY = Math.max(-r, Math.min(r, dy)) * 0.75;
      joyStick.style.transform = `translate(${visX}px, ${visY}px)`;

      updateMoveFlagsFromJoystick();
    }

    function updateMoveFlagsFromJoystick() {
      // Using joyValue.y for forward/back, joyValue.x for strafe
      controls.moveForward = joyValue.y > 0.25;
      controls.moveBackward = joyValue.y < -0.25;
      controls.moveLeft = joyValue.x < -0.25;
      controls.moveRight = joyValue.x > 0.25;
    }

    // LOOK AREA: touch drag changes camera rotation (yaw, pitch)
    lookArea.addEventListener('touchstart', (ev) => {
      ev.preventDefault();
      const t = ev.changedTouches[0];
      lookActive = true;
      lookId = t.identifier;
      lastLookPos.x = t.clientX;
      lastLookPos.y = t.clientY;
    }, {passive:false});

    lookArea.addEventListener('touchmove', (ev) => {
      ev.preventDefault();
      for (let t of ev.changedTouches) {
        if (t.identifier === lookId) {
          const dx = t.clientX - lastLookPos.x;
          const dy = t.clientY - lastLookPos.y;
          lastLookPos.x = t.clientX;
          lastLookPos.y = t.clientY;
          // Apply look change: translate touch delta to control rotation
          // FirstPersonControls uses internal lon/lat; we'll emulate mouse movement by calling handleEvent
          const lookSpeed = controls.lookSpeed * 0.8;
          // horizontal rotation (yaw)
          camera.rotation.y -= dx * 0.0025 * lookSpeed;
          // vertical rotation (pitch) with limits
          const newX = camera.rotation.x - dy * 0.0025 * lookSpeed;
          const maxPitch = 1.2; // ~70 degrees
          const minPitch = -1.2;
          camera.rotation.x = Math.max(minPitch, Math.min(maxPitch, newX));
        }
      }
    }, {passive:false});

    lookArea.addEventListener('touchend', (ev) => {
      ev.preventDefault();
      for (let t of ev.changedTouches) {
        if (t.identifier === lookId) {
          lookActive = false;
          lookId = null;
        }
      }
    }, {passive:false});

    /*********** Resize handling ***********/
    function onResize() {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
    }
    window.addEventListener('resize', onResize);

    /*********** Animation loop ***********/
    let lastTime = performance.now();
    function animate(now) {
      const dt = (now - lastTime) / 1000; // seconds
      lastTime = now;

      // For mobile joystick we already set controls.move* flags.
      // FirstPersonControls.update expects delta in seconds.
      controls.update(dt);

      renderer.render(scene, camera);
      requestAnimationFrame(animate);
    }
    requestAnimationFrame(animate);

    /*********** Helpful: center view on double click / double tap ***********/
    // Desktop double click recenters camera to front of model
    container.addEventListener('dblclick', () => {
      if (!currentModel) return;
      const box = new THREE.Box3().setFromObject(currentModel);
      const size = box.getSize(new THREE.Vector3());
      camera.position.set(0, Math.max(1.6, size.y * 0.6), Math.max(3, size.x * 1.2));
      camera.lookAt(0,0,0);
    });

    // Mobile double tap => same behaviour
    let lastTap = 0;
    container.addEventListener('touchend', (ev) => {
      const now = Date.now();
      if (now - lastTap < 300) {
        // double tap
        if (currentModel) {
          const box = new THREE.Box3().setFromObject(currentModel);
          const size = box.getSize(new THREE.Vector3());
          camera.position.set(0, Math.max(1.6, size.y * 0.6), Math.max(3, size.x * 1.2));
          camera.lookAt(0,0,0);
        }
      }
      lastTap = now;
    });

    /*********** Notes for you ***********
     - Tweak controls.movementSpeed and lookSpeed to taste.
     - Joystick sensitivity: change radius r in updateJoystickFromTouch.
     - The code keeps your model loading flow unchanged.
     - If you prefer pointer-lock style movement on desktop, I can swap FirstPersonControls -> PointerLockControls.
    ***************************************/

  </script>
</body>
</html>

</body>
</html>

