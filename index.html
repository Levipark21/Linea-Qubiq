<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8" />
  <title>Modelo 3D con Three.js y AR</title>
  <style>
    html, body {
      margin: 0; padding: 0;
      width: 100%; height: 100%;
      overflow: hidden;
      background-color: #ffffff;
      font-family: Arial, sans-serif;
      display: flex; flex-direction: column;
      align-items: center;
    }
    #title {
      margin: 10px 0 0 0;
      font-size: 20px;
      font-weight: bold;
      color: #222;
      background-color: rgba(255, 255, 255, 0.9);
      padding: 10px 20px;
      border-radius: 6px;
      text-align: center;
      user-select: none;
      width: 100%;
      max-width: 800px;
      z-index: 10;
      position: relative;
    }
    #modelSelector {
      margin: 10px 0;
      padding: 10px;
      font-size: 16px;
      border-radius: 5px;
      border: 1px solid #ccc;
      background-color: rgba(255, 255, 255, 0.85);
      max-width: 800px;
      width: 100%;
      z-index: 10;
      position: relative;
    }
    #canvas-container {
      flex: 1;
      width: 100%;
      max-width: 800px;
      background-color: #ffffff;
      border: none;
      position: relative;
      z-index: 1;
    }
    canvas {
      display: block;
      width: 100% !important;
      height: 100% !important;
    }
    /* Ajustamos el botón AR para que se muestre bien */
    .ar-button {
      position: fixed !important;
      bottom: 20px !important;
      left: 50% !important;
      transform: translateX(-50%) !important;
      z-index: 20 !important;
      background-color: #006eff !important;
      color: white !important;
      padding: 16px 32px !important;
      font-size: 20px !important;
      font-weight: bold !important;
      border: none !important;
      border-radius: 8px !important;
      cursor: pointer !important;
      box-shadow: 0 4px 10px rgba(0,0,0,0.2) !important;
      user-select: none !important;
    }
    .ar-button:hover {
      background-color: #0055cc !important;
    }
  </style>
</head>
<body>

  <div id="title">Levipark21 - Línea Qubiq</div>

  <select id="modelSelector">
    <option value="bichos.glb">QUBIQ</option>
    <option value="coco.glb">COCODRILO</option>
    <option value="koa.glb">KOALA</option>
    <option value="pingu.glb">PINGU</option>
  </select>

  <div id="canvas-container"></div>

  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.153.0/build/three.module.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/controls/OrbitControls.js';
    import { GLTFLoader } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/loaders/GLTFLoader.js';
    import { ARButton } from 'https://cdn.jsdelivr.net/npm/three@0.153.0/examples/jsm/webxr/ARButton.js';

    const repoPath = './';

    const container = document.getElementById('canvas-container');
    const selector = document.getElementById('modelSelector');

    // Renderer con WebXR habilitado
    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
    renderer.setSize(container.clientWidth, container.clientHeight);
    renderer.setClearColor(0xffffff, 1);
    renderer.xr.enabled = true;
    container.appendChild(renderer.domElement);

    // Escena y cámara
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
    camera.position.set(0, 1.5, 10);

    // Controles para vista normal (no AR)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.target.set(0, 1, 0);
    controls.update();

    // Luces
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
    scene.add(ambientLight);
    const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
    directionalLight.position.set(5, 10, 7);
    scene.add(directionalLight);

    const loader = new GLTFLoader();

    let currentModel = null;
    let modelPlaced = false; // Para controlar si ya se colocó el modelo en AR

    function loadModel(filename) {
      const path = repoPath + filename;
      console.log('Intentando cargar modelo:', path);

      if (currentModel) {
        scene.remove(currentModel);
        currentModel.traverse((child) => {
          if (child.geometry) child.geometry.dispose();
          if (child.material) {
            if (Array.isArray(child.material)) {
              child.material.forEach(mat => mat.dispose());
            } else {
              child.material.dispose();
            }
          }
        });
        currentModel = null;
      }

      loader.load(
        path,
        (gltf) => {
          console.log('Modelo cargado:', filename);
          currentModel = gltf.scene;

          // Para vista normal lo añadimos directo
          if (!renderer.xr.isPresenting) {
            scene.add(currentModel);

            // Centrar modelo
            const box = new THREE.Box3().setFromObject(currentModel);
            const center = box.getCenter(new THREE.Vector3());
            currentModel.position.sub(center);
          }
          modelPlaced = false; // Reiniciamos para AR
        },
        (xhr) => {
          if (xhr.lengthComputable) {
            console.log(`Carga: ${(xhr.loaded / xhr.total * 100).toFixed(2)}%`);
          }
        },
        (error) => {
          console.error('Error cargando modelo:', error);
        }
      );
    }

    loadModel(selector.value);

    selector.addEventListener('change', () => {
      loadModel(selector.value);
    });

    // Resize
    window.addEventListener('resize', () => {
      const w = container.clientWidth;
      const h = container.clientHeight;
      camera.aspect = w / h;
      camera.updateProjectionMatrix();
      renderer.setSize(w, h);
      console.log('Canvas size:', w, h);
    });

    // Botón AR oficial
    const arButton = ARButton.createButton(renderer, {
      requiredFeatures: ['hit-test'],
      optionalFeatures: ['dom-overlay'],
      domOverlay: { root: document.body }
    });
    arButton.classList.add('ar-button');
    document.body.appendChild(arButton);

    // Reticle para indicar superficie detectada
    const reticle = new THREE.Mesh(
      new THREE.RingGeometry(0.15, 0.2, 32).rotateX(-Math.PI / 2),
      new THREE.MeshBasicMaterial({ color: 0x00ff00 })
    );
    reticle.matrixAutoUpdate = false;
    reticle.visible = false;
    scene.add(reticle);

    // Variables para hit-test
    let hitTestSource = null;
    let hitTestSourceRequested = false;

    // Controlador para evento select
    const controller = renderer.xr.getController(0);
    controller.addEventListener('select', () => {
      if (reticle.visible && currentModel && !modelPlaced) {
        currentModel.position.setFromMatrixPosition(reticle.matrix);
        scene.add(currentModel);
        modelPlaced = true;  // Modelo colocado, no mover más
        console.log('Modelo colocado en AR');
      }
    });
    scene.add(controller);

    renderer.xr.addEventListener('sessionstart', () => {
      const session = renderer.xr.getSession();

      session.requestReferenceSpace('viewer').then((referenceSpace) => {
        session.requestHitTestSource({ space: referenceSpace }).then((source) => {
          hitTestSource = source;
        });
      });

      session.addEventListener('end', () => {
        hitTestSourceRequested = false;
        hitTestSource = null;
        reticle.visible = false;
        modelPlaced = false;
      });

      hitTestSourceRequested = true;
    });

    function animate(timestamp, frame) {
      if (frame) {
        const referenceSpace = renderer.xr.getReferenceSpace();
        const session = renderer.xr.getSession();

        if (hitTestSource) {
          const hitTestResults = frame.getHitTestResults(hitTestSource);

          if (hitTestResults.length > 0) {
            const hit = hitTestResults[0];
            const pose = hit.getPose(referenceSpace);
            reticle.visible = true;
            reticle.matrix.fromArray(pose.transform.matrix);
          } else {
            reticle.visible = false;
          }
        }
      }

      renderer.render(scene, camera);
    }

    renderer.setAnimationLoop(animate);
  </script>

</body>
</html>


